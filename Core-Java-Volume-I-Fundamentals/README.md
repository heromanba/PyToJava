
# Java 核心技术 卷I

## 第1章 Java程序设计概述
- 1.1 Java程序设计平台
- 1.2 Java“白皮书”的关键术语
  - 1.2.1 简单性
  - 1.2.2 面向对象
  - 1.2.3 分布式
  - 1.2.4 健壮性
  - 1.2.5 安全性
  - 1.2.6 体系结构中立
  - 1.2.7 可移植性
  - 1.2.8 解释型
  - 1.2.9 高性能
  - 1.2.10 多线程
  - 1.2.11 动态性
- 1.3 Java applet与Internet
- 1.4 Java发展简史
- 1.5 关于Java的常见误解

## 第2章 Java程序设计环境
- 2.1 安装Java开发工具包
  - 2.1.1 下载JDK
  - 2.1.2 设置JDK
  - 2.1.3 安装库源文件和文档
- 2.2 使用命令行工具
- 2.3 谁用集成开发环境
- 2.4 JShell

## 第3章 Java的基本程序设计结构
- 3.1 一个简单的Java应用程序
- 3.2 注释
- 3.3 数据类型
  - 3.3.1 整型
  - 3.3.2 浮点类型
  - 3.3.3 char类型
  - 3.3.4 Unicode和char类型
  - 3.3.5 boolean类型
- 3.4 变量与常量
  - 3.4.1 声明变量
  - 3.4.2 变量初始化
  - 3.4.3 常量
  - 3.4.4 枚举类型
- 3.5 运算符
  - 3.5.1 算术运算符
  - 3.5.2 数学函数与常量
  - 3.5.3 数值类型之间的转换
  - 3.5.4 强制类型转换
  - 3.5.5 结合赋值和运算符
  - 3.5.6 自增与自减运算符
  - 3.5.7 关系和boolean运算符
  - 3.5.8 位运算符
  - 3.5.9 括号与运算符级别
- 3.6 字符串
  - 3.6.1 子串
  - 3.6.2 拼接
  - 3.6.3 不可变字符串
  - 3.6.4 检测字符串是否相等
  - 3.6.5 空串与Null串
  - 3.6.6 码点与代码单元
  - 3.6.7 StringAPI
  - 3.6.8 阅读联机API文档
  - 3.6.9 构建字符串
- 3.7 输入与输出
  - 3.7.1 读取输入
  - 3.7.2 格式化输出
  - 3.7.3 文件输入与输出
- 3.8 控制流程
  - 3.8.1 快作用域
  - 3.8.2 条件语句
  - 3.8.3 循环
  - 3.8.4 确定循环
  - 3.8.5 多重选择：switch语句
  - 3.8.6 中断控制流程的语句
- 3.9 大数
- 3.10 数组
  - 3.10.1 声明数组
  - 3.10.2 访问数组元素
  - 3.10.3 for each循环
  - 3.10.4 数组拷贝
  - 3.10.5 命令行参数
  - 3.10.6 数组排序
  - 3.10.7 多维数组
  - 3.10.8 不规则数组

## 第4章 对象与类
- 4.1 面向对象程序设计概述
  - 4.1.1 类
  - 4.1.2 对象
  - 4.1.3 识别类
  - 4.1.4 类之间的关系
- 4.2 使用预定义类
  - 4.2.1 对象与对象变量
  - 4.2.2 Java类库中的LocalDate类
  - 4.2.3 更改器方法与访问器方法
- 4.3 用户自定义类
  - 4.3.1 Employee类
  - 4.3.2 多个源文件的使用
  - 4.3.3 剖析Employee类
  - 4.3.4 从构造器开始
  - 4.3.5 用var声明局部变量
  - 4.3.6 使用null引用
  - 4.3.7 隐式参数与显式参数
  - 4.3.8 封装的优点
  - 4.3.9 基于类的访问权限
  - 4.3.10 私有方法
  - 4.3.11 final实例字段
- 4.4 静态字段与静态方法
  - 4.4.1 静态字段
  - 4.4.2 静态常量
  - 4.4.3 静态方法
  - 4.4.4 工厂方法
  - 4.4.5 main方法
- 4.5 方法参数
- 4.6 对象构造
  - 4.6.1 重载
  - 4.6.2 默认字段初始化
  - 4.6.3 无参数的构造器
  - 4.6.4 显示字段初始化
  - 4.6.5 参数名
  - 4.6.6 调用另一个构造器
  - 4.6.7 初始化块
  - 4.6.8 对象析构与finalize方法
- 4.7 包
  - 4.7.1 包名
  - 4.7.2 类的导入
  - 4.7.3 静态导入
  - 4.7.4 在包中增加类
  - 4.7.5 包访问
  - 4.7.6 类路径
  - 4.7.7 设置类路径
- 4.8 JAR文件
  - 4.8.1 创建JAR文件
  - 4.8.2 清单文件
  - 4.8.3 可执行JAR文件
  - 4.8.4 多版本JAR文件
  - 4.8.5 关于命令行选项的说明
- 4.9 文档注释
  - 4.9.1 注释的插入
  - 4.9.2 类注释
  - 4.9.3 方法注释
  - 4.9.4 字段注释
  - 4.9.5 通用注释
  - 4.9.6 包注释
- 4.10 类设计技巧

## 第5章 继承
- 5.1 类、超类和子类
  - 5.1.1 定义子类
  - 5.1.2 覆盖方法
  - 5.1.3 子类构造器
  - 5.1.4 继承层次
  - 5.1.5 多态
  - 5.1.6 理解方法调用
  - 5.1.7 阻止继承：final类和方法
  - 5.1.8 强制类型转换
  - 5.1.9 抽象类
  - 5.1.10 受保护访问
- 5.2 Object:所有类的超类
  - 5.2.1 Object类型的变量
  - 5.2.2 equals方法
  - 5.2.3 相等测试与继承
  - 5.2.4 hasCode方法
  - 5.2.5 toString方法
- 5.3 泛型数组列表
  - 5.3.1 声明数组列表
  - 5.3.2 访问数组列表元素
  - 5.3.3 类型化与原始数组列表的兼容性
- 5.4 对象包装器与自动装箱
- 5.5 参数数量可变的方法
- 5.6 枚举类
- 5.7 反射
  - 5.7.1 Class类
  - 5.7.2 声明异常入门
  - 5.7.3 资源
  - 5.7.4 利用反射分析类的能力
  - 5.7.5 使用反射在运行时分析对象
  - 5.7.6 使用反射编写泛型数组代码
  - 5.7.7 调用任意方法和构造器
- 5.8 继承的设计技巧
  
## 第6章 接口、lambda表达式与内部类
- 6.1 接口
  - 6.1.1 接口的概念
  - 6.1.2 接口的属性
  - 6.1.3 接口与抽象类
  - 6.1.4 静态和私有方法
  - 6.1.5 默认方法
  - 6.1.6 解决默认方法冲突
  - 6.1.7 接口与回调
  - 6.1.8 Comparator接口
  - 6.1.9 对象克隆
- 6.2 lambda表达式
  - 6.2.1 为什么引入lambda表达式
  - 6.2.2 lambda表达式用法
  - 6.2.3 函数式接口
  - 6.2.4 方法引用
  - 6.2.5 构造器引用
  - 6.2.6 变量作用域
  - 6.2.7 处理lambda表达式
  - 6.2.8 再度Comparator
- 6.3 内部类
  - 6.3.1 使用内部类访问对象状态
  - 6.3.2 内部类的特殊语法规则
  - 6.3.3 内部类是否有用、必要和安全
  - 6.3.4 局部内部类
  - 6.3.5 由外部方法访问变量
  - 6.3.6 匿名内部类
  - 6.3.7 静态内部类
- 6.4 服务加载器
- 6.5 代理
  - 6.5.1 何时使用代理
  - 6.5.2 创建代理对象
  - 6.5.3 代理类的特性

## 第7章 异常、断言和日志
- 7.1 处理错误
  - 7.1.1 异常分类
  - 7.1.2 声明检查型异常
  - 7.1.3 如何抛出异常
  - 7.1.4 创建异常类
- 7.2 捕获异常
  - 7.2.1 捕获异常
  - 7.2.2 捕获多个异常
  - 7.2.3 再次抛出异常与异常链
  - 7.2.4 finally子句
  - 7.2.5 try-with-Resources语句
  - 7.2.6 分析堆栈轨迹元素
- 7.3 使用异常的技巧
- 7.4 使用断言
  - 7.4.1 断言的概念
  - 7.4.2 启用和禁用断言
  - 7.4.3 使用断言完成参数检查
  - 7.4.4 使用断言提供假设文档
- 7.5 日志
  - 7.5.1 基本日志
  - 7.5.2 高级日志
  - 7.5.3 修改日志管理器配置
  - 7.5.4 本地化
  - 7.5.5 处理器
  - 7.5.6 过滤器
  - 7.5.7 格式化器
  - 7.5.8 日志技巧
- 7.6 调试技巧

## 第8章 泛型程序设计
- 8.1 为什么使用泛型程序设计
  - 8.1.1 类型参数的好处
  - 8.1.2 谁想成为泛型程序员
- 8.2 定义简单泛型类
- 8.3 泛型方法
- 8.4 类型变量的限定
- 8.5 泛型代码和虚拟机
  - 8.5.1 类型擦除
  - 8.5.2 转换泛型表达式
  - 8.5.3 转换泛型方法
  - 8.5.4 调用遗留代码
- 8.6 限制与局限性
  - 8.6.1 不能用基本类型实例化类型参数
  - 8.6.2 运行时类型查询只适用于原始类型
  - 8.6.3 不能创建参数化类型的数组
  - 8.6.4 Varargs警告
  - 8.6.5 不能实例化类型变量
  - 8.6.6 不能构造泛型数组
  - 8.6.7 泛型类的静态上下文中类型变量无效
  - 8.6.8 不能抛出或捕获泛型类的实例
  - 8.6.9 可以取消对检查型异常的检查
  - 8.6.10 注意擦除后的冲突
- 8.7 泛型类型的继承规则
- 8.8 通配符类型
  - 8.8.1 通配符概念
  - 8.8.2 通配符的超类型限定
  - 8.8.3 无限定通配符
  - 8.8.4 通配符捕获
- 8.9 反射和泛型
  - 8.9.1 泛型Class类
  - 8.9.2 使用Class\<T\>参数进行类型匹配
  - 8.9.3 虚拟机中的泛型类型信息
  - 8.9.4 类型字面量

## 第9章 集合
- 9.1 Java集合框架
  - 9.1.1 集合接口与实现分离
  - 9.1.2 Collection接口
  - 9.1.3 迭代器
  - 9.1.4 泛型实用方法
- 9.2 集合框架中的接口
- 9.3 具体集合
  - 9.3.1 链表
  - 9.3.2 数组列表
  - 9.3.3 散列表
  - 9.3.4 树集
  - 9.3.5 队列与双端队列
  - 9.3.6 优先队列
- 9.4 映射
  - 9.4.1 基本映射操作
  - 9.4.2 更新映射条目
  - 9.4.3 映射视图
  - 9.4.4 弱散列映射
  - 9.4.5 链接散列集与映射
  - 9.4.6 枚举集与映射
  - 9.4.7 标识散列映射
- 9.5 视图与包装器
  - 9.5.1 小集合
  - 9.5.2 子范围
  - 9.5.3 不可修改的视图
  - 9.5.4 同步视图
  - 9.5.5 检查型视图
  - 9.5.6 关于可选操作的说明
- 9.6 算法
  - 9.6.1 为什么使用泛型算法
  - 9.6.2 排序与混排
  - 9.6.3 二分查找
  - 9.6.4 简单算法
  - 9.6.5 批操作
  - 9.6.6 集合与数组的转换
  - 9.6.7 编写自己的算法
- 9.7 遗留的集合
  - 9.7.1 Hashtable类
  - 9.7.2 枚举
  - 9.7.3 属性映射
  - 9.7.4 栈
  - 9.7.5 位集

## 第10章 图形用户界面程序设计
- 10.1 Java用户界面工具包简史
- 10.2 显示窗体
  - 10.2.1 创建窗体
  - 10.2.2 窗体属性
- 10.3 在组件中显示信息
  - 10.3.1 处理2D图形
  - 10.3.2 使用颜色
  - 10.3.3 使用字体
  - 10.3.4 显示图像
- 10.4 事件处理
  - 10.4.1 基本事件处理概念
  - 10.4.2 实例：处理按钮点击事件
  - 10.4.3 简洁的指定监听器
  - 10.4.4 适配器类
  - 10.4.5 动作
  - 10.4.6 鼠标事件
  - 10.4.7 AWT事件继承层次
- 10.5 首选项API

## 第11章 Swing用户界面组件
- 11.1 Swing和模型-视图-控制器设计模式
- 11.2 布局管理概述
  - 11.2.1 布局管理器
  - 11.2.2 边框布局
  - 11.2.3 网格布局
- 11.3 文本输入
  - 11.3.1 文本域
  - 11.3.2 标签和标签组件
  - 11.3.3 密码域
  - 11.3.4 文本区
  - 11.3.5 滚动窗格
- 11.4 选择组件
  - 11.4.1 复选框
  - 11.4.2 单选按钮
  - 11.4.3 边框
  - 11.4.4 组合框
  - 11.4.5 滑动条
- 11.5 菜单
  - 11.5.1 菜单构建
  - 11.5.2 菜单项中的图片
  - 11.5.3 复选框和单选按钮菜单项
  - 11.5.4 弹出菜单
  - 11.5.5 键盘助记符和加速器
  - 11.5.6 启用和禁用菜单项
  - 11.5.7 工具条
  - 11.5.8 工具提示
- 11.6 复杂的布局管理
  - 11.6.1 网格包布局
  - 11.6.2 定制布局管理器
- 11.7 对话框
  - 11.7.1 选项对话框
  - 11.7.2 创建对话框
  - 11.7.3 数据交换
  - 11.7.4 文件对话框

## 第12章 并发
- 12.1 什么是线程
- 12.2 线程状态
  - 12.2.1 新建线程
  - 12.2.2 可运行线程
  - 12.2.3 阻塞和等待线程
  - 12.2.4 终止线程
- 12.3 线程属性
  - 12.3.1 终端线程
  - 12.3.2 守护线程
  - 12.3.3 线程名
  - 12.3.4 未捕获异常的处理器
  - 12.3.5 线程优先级
- 12.4 同步
  - 12.4.1 竞态条件的一个例子
  - 12.4.2 竞态条件详解
  - 12.4.3 锁对象
  - 12.4.4 条件对象
  - 12.4.5 synchronized关键字
  - 12.4.6 同步块
  - 12.4.7 监视器概念
  - 12.4.8 volatile字段
  - 12.4.9 final变量
  - 12.4.10 原子性
  - 12.4.11 死锁
  - 12.4.12 线程局部变量
  - 12.4.13 为什么废弃stop和suspend方法
- 12.5 线程安全的集合
  - 12.5.1 阻塞队列
  - 12.5.2 高效的映射、集和队列
  - 12.5.3 映射条目的原子更新
  - 12.5.4 对并发散列映射的批操作
  - 12.5.5 并发集视图
  - 12.5.6 写数组的拷贝
  - 12.5.7 并行数组算法
  - 12.5.8 较早的线程安全集合
- 12.6 任务和线程池
  - 12.6.1 Callable与Future
  - 12.6.2 执行器
  - 12.6.3 控制任务组
  - 12.6.4 fork-join框架
- 12.7 异步计算
  - 12.7.1 可完成Future
  - 12.7.2 组合可完成Future
  - 12.7.3 用户界面回调中的长时间运行任务
- 12.9 进程
  - 12.8.1 建立一个进程
  - 12.8.2 运行一个进程
  - 12.8.3 进程句柄
  